<!doctype html><html lang=zh-tw itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Reverb plugin - eri24816's blog</title>
<meta name=description content="我學到非常多好玩的觀念，像是 z transform、怎麼看 zero pole plot、如何用 C++ 來 OOP (踩各種指標的坑XD)。"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"eri24816\u0027s blog","url":"https:\/\/eri24816.tw\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/eri24816.tw\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/eri24816.tw\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/eri24816.tw\/post\/reverb_plugin\/","name":"Reverb plugin"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":""},"headline":"Reverb plugin","description":"我學到非常多好玩的觀念，像是 z transform、怎麼看 zero pole plot、如何用 C\u002b\u002b 來 OOP (踩各種指標的坑XD)。","inLanguage":"zh-tw","wordCount":547,"datePublished":"2022-03-16T17:33:37","dateModified":"2022-03-16T17:33:37","image":"https:\/\/eri24816.tw\/","keywords":["c\u002b\u002b"],"mainEntityOfPage":"https:\/\/eri24816.tw\/post\/reverb_plugin\/","publisher":{"@type":"Organization","name":"https:\/\/eri24816.tw\/","logo":{"@type":"ImageObject","url":"https:\/\/eri24816.tw\/","height":60,"width":60}}}</script><meta property="og:title" content="Reverb plugin"><meta property="og:description" content="我學到非常多好玩的觀念，像是 z transform、怎麼看 zero pole plot、如何用 C++ 來 OOP (踩各種指標的坑XD)。"><meta property="og:image" content="https://i.imgur.com/8qGh9bk.png"><meta property="og:url" content="https://eri24816.tw/post/reverb_plugin/"><meta property="og:type" content="website"><meta property="og:site_name" content="eri24816's blog"><link rel=apple-touch-icon sizes=180x180 href=https://eri24816.tw/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://eri24816.tw/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://eri24816.tw/favicon/favicon-16x16.png><meta name=generator content="Hugo 0.138.0"><link rel=alternate href=https://eri24816.tw/index.xml type=application/rss+xml title="eri24816's blog"><script src=https://eri24816.tw/js/dark-mode.js></script><link rel=stylesheet href=/style.min.css><link rel=stylesheet href=https://eri24816.tw/custom.css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href=/vendor/glightbox/css/glightbox.min.css rel=stylesheet><script src=https://eri24816.tw/vendor/glightbox/js/glightbox.min.js></script></head><body><img src=https://i.imgur.com/pBOqZZb.png alt=bg class=bg-img>
<script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelector(".bg-img"),s=document.querySelector(".index"),t=document.querySelector(".index-container");function n(){const n=window.pageYOffset||document.documentElement.scrollTop,i=n/300,a=Math.min(2,n/400);let o;s?o=Math.max(.2,.8-n/300):o=.2,t&&(t.style.opacity=i),e&&(e.style.filter=`brightness(${o})`,e.style.top=`${.7*n}px`)}n(),window.addEventListener("scroll",n)})</script><div class="container fixed-top mw-100"><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-10 col-xl-10"><nav class="navbar navbar-expand-lg navbar-light fixed-top p-0"><div class=container><a class="navbar-brand fw-bold" href=https://eri24816.tw/>eri24816's blog</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse justify-content-end" id=navbarNav><ul class="navbar-nav mb-2 mb-lg-0 align-items-baseline"><li class="nav-item dropdown"><button class="p-1 rounded dropdown-toggle border-gray-500" data-bs-toggle=dropdown aria-expanded=false>
zh-tw</button><ul class=dropdown-menu><li><a class="dropdown-item active" aria-current=page href=https://eri24816.tw/post/reverb_plugin/>繁體中文</a></li></ul></li><li class="nav-item nav-link"><a id=dark-mode-toggle class="bi bi-moon-stars" role=button></a></li></ul></div></div></nav></div></div></div><header class=header-section><div class="intro-header no-img mt-10"><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-8 col-xl-8"><div class="col-sm-12 col-md-12 col-lg-12 col-xl-12"><div class=post-heading><h1 class="fw-semibold display-5 lh-1 mb-3">Reverb plugin</h1><span class=post-meta><div class="row post-meta text-muted"><div class="col-sm-12 col-md-6 px-0">&nbsp; March 16, 2022</div><div class="col-sm-12 col-md-6 text-sm-start text-md-end px-0"></div></div></span></div></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 pt-4"><article role=main class=blog-post><p>一直想做的東西後來真的有課教我怎麼做，就會覺得那門課很吸引我。</p><p>在「數位音樂訊號分析」這門課中，每組學生使用 JUCE(一個製作 VST 的 C++ 框架)來做一種 VST 效果器。我們這組做的是 reverb。Reverb 的功用是把音樂加上迴音，像是在大教堂或音樂廳的感覺。</p><p>這門課是我這一年遇過最好玩的。我學到非常多好玩的觀念，像是 z transform、怎麼看 zero pole plot、如何用 C++ 來 OOP (踩各種指標的坑XD)。</p><h2 id=整體架構>整體架構</h2><p>下圖是我們一開始參考的架構。</p><p><img alt=Image src=https://i.imgur.com/gLgWwXH.jpg#center>
<a href=https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html>https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html</a></p><p>首先，輸入的 2 個 channel 被一個 2*8 matrix 分成 8 個 channel，接著進入迴圈。迴圈裡都是 8 個 channel 在跑，訊號會依序經過 allpass、feedback matrix、lowpass、delay line 四個基礎 filter，然後重複。在 feedback matrix 後面有一條脫離迴圈的輸出路徑，會經過一個 8*2 的 matrix，輸出到 2 個 channel。</p><p>這看似簡單(我們只要把每個基本模組實做出來即可)，但困難點在於這兩項性質難以同時兼顧:</p><ol><li>產生的聲音好聽</li><li>IIR的穩定性</li></ol><p>這是因為我們使用的是帶有迴圈的 IIR，所以參數沒調好的話會不穩定 (unstable)。如果使用的是 FIR 則能免除這項困難，但是如果用 FIR 做 reverb，計算量會太大。所以在建好架構後，我們花了大半的時間在嘗試找出在 IIR 穩定的情況下，聲音最好聽的參數。</p><h2 id=各模組的實作>各模組的實作</h2><p>在我們的實作中有很多種模組 (例如 DelayLine，LowPass)，每種模組都是一個多 channel 的 causal filter。一個大模組裡面可能包含數個小模組，而完整的 Reverb 本身就是一個最大的模組。</p><p>每種模組皆有實作方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> update(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input)
</span></span></code></pre></div><p>在 VST 的每一個 time step，這個方法都會收到一個 float 陣列作為輸入，計算完後輸出一個 float 陣列。大部分的模組都具有 memory，所以 update() 方法不是 time independent 的。</p><h3 id=delayline>DelayLine</h3><p>DelayLine 的功能單純就是在收到訊號後延遲數個 sample 的時間再輸出，在頻域上的作用為$z^{-n}$。用 std::queue 就可以簡單地把它實做出來。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> inputDim; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        queues[i].push(input[i]);
</span></span><span style=display:flex><span>        outputBuffer[i] <span style=color:#f92672>=</span> queues[i].front();
</span></span><span style=display:flex><span>        queues[i].pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> outputBuffer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>後來為了減少耗時，我又自己刻了一個沒有用到 std::queue 的版本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> inputDim; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        outputBuffer[i] <span style=color:#f92672>=</span> arr[i][pos[i]];
</span></span><span style=display:flex><span>        arr[i][pos[i]] <span style=color:#f92672>=</span> input[i];
</span></span><span style=display:flex><span>        pos[i]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pos[i] <span style=color:#f92672>==</span> len[i])pos[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> outputBuffer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=lowpass>Lowpass</h3><p>這個模組是一階 low pass filter，頻域上的作用為$(1-a)+az^{-1}$。</p><p>實作的方法是把前一個輸出以某個權重加回當前的輸入，以此作為輸出。也就是在波型上做 smoothing。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>    mult(inputDim, input, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> a);
</span></span><span style=display:flex><span>    mult(inputDim, feedback, a);
</span></span><span style=display:flex><span>    add(inputDim, input, feedback);
</span></span><span style=display:flex><span>    copy(inputDim, feedback, input);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mult(inputDim, input,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 這些 code 長得很像 assembly 是因為我沒有定義 vector 這個 class 和它的 operators，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 只有草率定義了幾個對 float 陣列的運算。我當時太懶了XD
</span></span></span></code></pre></div><p>a 是調控 cutoff frequency 的參數，它們的關係是:
$$a=e^{-2\pi \frac{ \mathit{Cutoff}} {\mathit{SampleRate}}}$$</p><h3 id=allpass>Allpass</h3><p>它是二階的 all pass filter。這是這個 project 最難做的 filter，我們必須由該 filter 應具有的性質，推導出實作的方法。</p><p>二階 all pass filter 的 pole-zero plot 有兩個 poles 和兩個 zeros，且此 filter 的性質受到以下限制:</p><ol><li>根據 complex conjugate root theorem，兩個 poles(zeros) 必共軛</li><li>為了讓各頻率的 amplitude response 皆維持在 1，每個 pole 對單位圓的反演處必須有一個 zero，反之亦然</li></ol><p>結合這兩項限制，代表我們只需要一組參數 $(r,θ)$ 來控制某一個 pole 的位置，即可以決定所有 pole 和 zero 的位置，也決定了這個二階 filter。</p><p><img alt=Image src=https://i.imgur.com/4HVI7Xu.png#centers></p><p>接下來就是用 $(r,θ)$ 來推出 IIR 的結構。</p><p>設此 filter 的 response 為 $H(z)=\frac{P(z)}{Q(z)}$，$P$ 的兩根為 zero，$Q$ 的兩根為 pole。以此為出發點，P 和 Q 為:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>$$\begin{aligned}
P(z) &= r^2(z-r^{-1}e^{iθ}) (z-r^{-1}e^{-iθ}) \\
&=r^2z^2-r(e^{iθ}+e^{-iθ})z+1\\
&=r^2z^2-2r\cos(θ)z+1
\end{aligned}$$</p><p>$$\begin{aligned}
Q(z)&=(z-re^{iθ})(z-re^{-iθ})\\
&=z^2-r(e^{iθ}+e^{-iθ})z+r^2\\
&=z^2-2r\cos(θ)z+r^2
\end{aligned}$$</p><p>令$X(z)$為輸入，$Y(z)$為輸出:
$$\begin{aligned}
Y(z)&=H(z)X(z)\\
&=\frac{P(z)}{Q(z)}X(z)\\
\end{aligned}$$</p><p>$$\begin{aligned}
Q(z)Y(z)&=P(z)X(z)\\
(z^2-2r\cos(θ)z+r^2)Y(z)&=(r^2z^2-2r\cos(θ)z+1)X(z)\\
(1-2r\cos(θ)z^{-1}+r^2z^{-2})Y(z)&=(r^2-2r\cos(θ)z^{-1}+z^{-2})X(z)\\
\end{aligned}$$</p><p>經過移項，最後可以得到以下 difference equation:
$$y[n] = r^2 * x[n]-2r\cos(θ) * x[n-1]+x[n-2]+2r \cos(θ) * y[n-1]-r^2* y[n-2]$$</p><p>其中，$x[n]$為目前輸入的 sample，$y[n]$為目前欲輸出的 sample。因為計算 $y[n]$ 會用到 4 個以前的值，所以此 filter 需要 4 條 delay line(或 4 個 memory)。實作如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input)<span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>inputDim;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        output[i] <span style=color:#f92672>=</span> R2[i] <span style=color:#f92672>*</span> input[i] <span style=color:#f92672>-</span> twoRCosTheta[i] <span style=color:#f92672>*</span> x1[i] <span style=color:#f92672>+</span> x2[i] <span style=color:#f92672>+</span> twoRCosTheta[i] <span style=color:#f92672>*</span> y1[i] <span style=color:#f92672>-</span> R2[i]<span style=color:#f92672>*</span>y2[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        x2[i] <span style=color:#f92672>=</span> x1[i];
</span></span><span style=display:flex><span>        x1[i] <span style=color:#f92672>=</span> input[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        y2[i] <span style=color:#f92672>=</span> y1[i];
</span></span><span style=display:flex><span>        y1[i] <span style=color:#f92672>=</span> output[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=comb>Comb</h3><p>Comb 超簡單，因為它是 FIR，沒有 feedback:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input)<span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>    add(inputDim, input, delay.update(input));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> input;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img alt=Image src=https://i.imgur.com/u0USmfH.png#centers></p><p>(但其實這個沒有用到，我們用 all pass 代替它了</p><h3 id=reverb>Reverb</h3><p>Reverb 這個最大的 filter 就是把所有小 filter 組裝起來。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span>{
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> dry[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    copy(inputDim, dry, input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input <span style=color:#f92672>=</span> distrib <span style=color:#f92672>*</span> inDelay.update(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    delayFilters.update(feedBack);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    add(NCH,input, fbDelayLine.update(feedBack));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input <span style=color:#f92672>=</span> allpass.update(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input <span style=color:#f92672>=</span> mult(inputDim, input, _decay);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> output <span style=color:#f92672>=</span> feedbackmatrix <span style=color:#f92672>*</span> input;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    copy(NCH,feedBack, output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dcBlocker.update(add(inputDim,mult(inputDim,outDistrib<span style=color:#f92672>*</span>output,wetAmount), mult(inputDim, dry,dryAmount)));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=調整參數>調整參數</h2><p>把所有 filter 組裝起來之後，我們遇到的第一個問題是跑了一段時間後數值很容易爆炸。這是因為在主迴圈中，如果有某個頻率的 amplitude response 超過 1，經過數次遞迴，那個頻率的強度就會指數發散。</p><p>我們隨即調低迴圈的 feedback matrix 的值，使得 amplitude response 下降。這時又出現另一個問題:殘響時間不夠長。當迴圈的 amplitude response 小於 1 太多，經過數次遞迴，聲音就會快速衰減並消失。</p><p>也就是說，必須讓每種頻率的 amplitude response 都小於 1，但只能小一點點。</p><p>後來我們找到的作法是:</p><ol><li>low pass 的 amplitude response 小於等於 1</li><li>all pass 的 amplitude response 等於 1 (當然)</li><li>feedback matrix 的每個 row 絕對值總和稍微小於 1</li></ol><p>這樣的話就可以保證不會爆炸了。原因如下:
以最嚴格的情況來看，假設 low pass 和 all pass 的 amplitude response 都是 1，訊號從 feedback matrix 的輸出繞一圈回到 feedback matrix 前的 amplitude 增益就是 1，強度不變。而 feedback matrix 會將 8 個 channel 重新混合，feedback matrix 的每個 row 絕對值總和小於 1 這項限制保證了混合後的訊號不會因疊加而增強。</p><p>不過因為訊號繞了一圈後，會發生複雜的項位改變，就算 feedback matrix 每個 row 絕對值總和非常接近 1，訊號卻很容易因為破壞性疊加而有很大的衰減率。而且 VST 的 sample rate 非常高(例如44100Hz)，所以還是會有不到 1 秒聲音就幾乎不見的情況。後來我們對這個問題的解法是在 IIR 前串聯約 50ms 的 convolution (FIR) ，最終效果不錯。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>國中學了但從未用過的根與係數終於在這裡用到了，覺得國中很浪費時間的心情稍稍下降了一點。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>第一行的 $r^2$ 用於 normalize&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></div><div class=row><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1"><hr class=m-0></div><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 pt-2"><div class=blog-tags><a href=https://eri24816.tw/tags/c++/>c++</a></div></div><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 pt-4"></div><div class="col-lg-8 offset-lg-2 col-md-12 offset-md-1 pt-4"><ul class="list-group list-group-horizontal" style=flex-direction:row><li class="list-group-item b-0 p-0"><a type=button class="btn btn-dark" role=button href=https://eri24816.tw/post/rnn_tutorial/ data-toggle=tooltip data-placement=top title="PyTorch RNN Tutorial">&larr;
上一篇</a></li><li class="list-group-item ms-auto b-0 p-0"><a type=button class="btn btn-dark" role=button href=https://eri24816.tw/post/dream_of_music_generation/ data-toggle=tooltip data-placement=top title=生成音樂的夢>下一篇
&rarr;</a></li></ul></div><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1 pt-4"></div></div></div><div></div><footer><div class=container><div class=row><div class=col-md-12><ul class="list-inline list-group list-group-horizontal text-center footer-links d-flex justify-content-center flex-row"></ul></div></div><div class=row><div class=col-md-12><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2024
&nbsp;&bull;&nbsp;
<a href=https://eri24816.tw/>eri24816's blog</a></p><p class="credits theme-by text-muted">Powered by <a href=https://gohugo.io>Hugo</a> & <a href=https://github.com/binokochumolvarghese/lightbi-hugo>Lightbi.</a>&nbsp; Made with ❤ by <a href=https://binovarghese.com>Bino</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js integrity=sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL crossorigin=anonymous></script></body></html>